
//ПОДКЛЮЧЕНИЯ К ФАЙЛАМ, БАЗАМ ДАННЫХ, СЕТЕВЫЕ ПОДКЛЮЧЕНИЯ

//Большинство объектов, используемых в программах на C#, относятся к управляемым или managed-коду. Такие объекты управляются CLR и легко очищаются сборщиком мусора. Однако вместе с тем встречаются также и такие объекты, которые задействуют неуправляемые объекты (подключения к файлам, базам данных, сетевые подключения и т.д.). Такие неуправляемые объекты обращаются к API операционной системы. Сборщик мусора может справиться с управляемыми объектами, однако он не знает, как удалять неуправляемые объекты. В этом случае разработчик должен сам реализовывать механизмы очистки на уровне программного кода.

//Освобождение неуправляемых ресурсов подразумевает реализацию одного из двух механизмов:

//Создание деструктора

//Реализация классом интерфейса System.IDisposable
using System.Xml.Linq;
//1
Console.WriteLine(GC.GetTotalMemory(false));

for (int i = 0; i < 10000000; i++)
{
    //боксим
    var obj = (object)i;
    int j = (int)obj;
}

Console.WriteLine(GC.GetTotalMemory(false));

//2 Dispose - конструкция try...finally
//когда выходим из зоны видимости юзинга отрабатывает Dispose 
using (var c = new MyClass())
{
    Console.WriteLine(GC.GetTotalMemory(false));
}

Console.WriteLine(GC.GetTotalMemory(false));

GC.Collect();

//3 ~ реализует Finalize
Console.WriteLine(GC.GetTotalMemory(false));

Test();
GC.Collect();   // очистка памяти под объект tom
Console.WriteLine(GC.GetTotalMemory(false));

void Test()
{
    Person tom = new Person("Tom");
}

public class Person
{
    public string Name { get; }
    public Person(string name) => Name = name;

    ~Person()
    {
        Console.WriteLine($"{Name} has been deleted");
    }
}

//Метод Finalize уже определен в базовом для всех типов классе Object, однако данный метод нельзя так просто переопределить. И фактическая его реализация происходит через создание деструктора.
class MyClass : IDisposable
{
    public MyClass() { }

    ~MyClass()
    {
        Console.WriteLine($"Object has deleted");
        //в реальных программах в деструктор вкладывается логика освобождения неуправляемых ресурсов.
    }

    //финализатор
    public void Dispose()
    {
        Console.WriteLine($"Object has disposed");
    }

    //на деле при очистке сборщик мусора вызывает не деструктор, а метод Finalize. Все потому, что компилятор C# компилирует деструктор в конструкцию, которая эквивалентна следующей:
    //protected override void Finalize()
    //{
    //    try
    //    {
    //        // здесь идут инструкции деструктора
    //    }
    //    finally
    //    {
    //        base.Finalize();
    //    }
    //}
}


//Когда Garbage Collector начинает удалять неиспользуемые данные из кучи в памяти? - Garbage Collector начинает удаление объектов, когда на куче отсутствует место для создания нового объекта или операционная система сигнализирует отсутствие свободного места в памяти. Как правило очистка происходит тогда, когда приложении наименее нагружено.
//Почему Garbage Collector начинает удалять неиспользуемые данные из кучи только в таких исключительных случаях? – Очистка памяти – это ресурсоемкий процесс, к тому же состояние объектов, которые остаются в памяти должно быть неизменно, поэтому работа всех потоков, связанных с приложением, приостанавливается. Из этого следует, что процесс очистки памяти не может запускаться слишком часто, так как это будет значительно влиять на производительность нашего приложения.
//Как Garbage Collector знает, какие объекты должны быть удалены? – Объекты на куче, на которые отсутствуют ссылки в стеке являются объектами, которые будут удалены Garbage Collector’ом. Давайте еще раз разберем это предложение. Чтобы получить доступ к объекту в памяти из нашего кода у нас должна быть ссылка на объект, которая расположена на стеке. Если такое ссылки нет, то это значит, что мы не можем воспользоваться объектом на куче – у нас просто нет к нему доступа. Если у нас нет доступа к объекту, и мы не можем им воспользоваться, то такой объект на куче является бесполезным и будет удален сборщиком мусора.
//Что конкретно делает Garbage Collector во время очистки памяти? – Сборщик мусора действует по принципу «помечай и собирай». Во время очистки он «помечает» используемые объекты и «собирает» их все вместе в определенном месте в памяти, делая размещение данных в памяти более компактным. Также после перемещения объектов в памяти восстанавливаются указатели на эти объекты.
//Что происходит с объектами, которые «пережили» очистку Garbage Collector? – Изначально объекты приписываются к так называемой «генерации 0». Если объекты не были удалены во время очистки, то высока вероятность что данные объекты являются важными и будут существовать в приложении еще како-то время. Такие объекты приписываются к «генерации 1». Есть еще «генерация 2», в которую попадают все объекты, которые остались в памяти после двух и более очисток.
//С какой целью объекты в памяти приписываются к определенным генерациям Garbage Collector’ом? – Как уже было сказано, очистка памяти – это ресурсоемкий процесс, и он занял бы значительное время при проверке всех объектов. Для минимизации времени работы Garbage Collector’а, при первой попытке очистки – проверяются объекты только «генерации 0». Если был освобожден достаточный объем памяти, то больше ничего не происходит, работа Garbage Collector’а прекращается. Однако если памяти всё еще недостаточно, начинается очистка объектов «генерации 1», и так далее до «генерации 2».
//Можно ли программно вызвать очистку памяти Garbage Collector’ом? – Можно. Для этого используется статический метод System.GC.Collect(), однако, как правило, этот метод используется довольно редко. Примеры ситуаций когда необходимо явно вызвать очистку: 1. Перед началом исполнения кода, который не может (и не должен) быть прерван Garbage Collector’ом во время исполнения. 2. После создания большего количества объектов в приложении, необходимо очистить памяти и освободить некоторые ресурсы.
